# Вложенность в Postgres

В этой статье я хочу подсветить проблему вложенности в Postgres, в частности в JDBC драйвере.

Предположим я хочу написать WEB-приложение, пусть это будет блог для простоты.
В предметной области есть Посты и Комментарии.
И на первой же странице нам нужно вывести спискок постов. Все просто:

```sql
select * from posts;
```

А теперь нужно вывести количество комментариев для поста.
Первым запросом извлекаем посты, а потом для каждого считаем количество комментариев.
И в приложении объединяем результаты.

```sql
select * from posts;

-- for each post:
select count(*) from comments where post_id = :post_id
```

Давайте выведем еще и самый популярный комментарий. Или давайте сразу 3.

```sql
select * from posts;

-- for each post:
select count(*) from comments where post_id = :post_id;
select id, text from comments where post_id = :post_id order by rank desc limit 1;
select id, text from comments where post_id = :post_id order by rank desc limit 3;
```

Запросы элементарные, я написал их по памяти вообще не задумываясь и уверен в их корректности.
Есть только одна проблема, а именно N+1 проблема. Мы для каждого поста из первого запроса делаем
еще запрос комментариев. И каждый раз ждем, пока наши байтики по сети сходят до базы и обратно.
Если у нас пинг до базы - 0,5 мс, а это еще хорошо, то для сотни постов мы потратим 50мс только на сеть.
И это если нам нужно получить только комментарии, а если еще данные по авторам - еще 50 мс,
по авторам комментариев - еще 50мс, итого 150 мс только на сеть. А если сеть хуже?

И вроде бы даже есть prepared statements, вроде бы хорошо ложатся на задачу.
Эй Postgres, смотри, я сейчас буду выполнять 100 однотипных запросов,
скомпилируй план, вот тебе 100 параметров - выполняй. Так, нет, Postgres умеет в pipeline только на insert/update запросах,
а не select. Не знаю, может быть протокол и поддерживает такое, но JDBC - нет:

+ [Support batching select statement executions](https://github.com/pgjdbc/pgjdbc/issues/2511)
+ [Support pipelining queries](https://github.com/pgjdbc/pgjdbc/issues/2325)




И нам ведь нужен не только текст комментария, но и его id, чтобы сформировать ссылку на него.
Вроде бы простая задача?


```sql
select *, count(comments.id)
from posts
left outer join comments on posts.id = comments.id;
```



Эти запросы я написал по памяти и я уверен, они правильные.
Одна проблема - мы ждем сеть, нам нужно послать последовательно N+1 запросов,
каждый раз тратя время на сеть.

Я знаю 2 решения этой проблемы.

Первое, и самое очевидное, это сгруппировать независимые запросы и послать их серверу одним пакетом.


А теперь давайте


Тут нужно внимательно посмотреть на запрос.
Появился join. Появилась агрегационная функция.




https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/multiset-value-constructor/



***




К счастью у нас есть Postgres, таблички и множество типов, вроде timestamptz, tsrange, пользовательские типы.



Clojure это такой динамический язык программирования со строгой типизацией,
где обычно программируют мапами и списками, не создавая типов или классов.
Иногда, когда требуется различать тип, то посто добавляют еще один ключ `:type`.

```clojure
{:id 42
 :first-name "John"
 :last-name "Doe"
 :type :user}

{:id 33
 :title "My awesome work"
 :content "..."
 :type :title}
```

У такого подхода есть свои плюсы, минусы, но речь не об этом.
Важно то, что мы не создаем класс под каждый тип.

А еще у нас есть Postgres с табличками и

проблема

показать частичное решение

ответ в телеге




https://t.me/pgsql/471208
https://t.me/pgsql/471347

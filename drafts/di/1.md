Я хотел бы рассказать про DI — фреймворк внедрения зависимостей для Clojure, почему он появился и какие мои проблемы решает.
Я успешно использую его в продакшене вот уже 2,5 года.
Сначала я расскажу про основную концепцию, а затем мы перейдем к реальным потребностям моего проекта.

Для управления состоянием приложения существует несколько фреймворков: Component, Mount, Integrant.
Они действительно решают проблему жизненного цикла компонентов, что является важной частью REPL-driven development.
Эти фреймворки оперируют компонентами, которые запускаются и останавливаются в правильном порядке,
что позволяет запускать одну или сразу несколько систем компонентов, например, одну для разработки, а другую для тестов.

Однако, при разработке своего приложения я столкнулся с проблемами, которые шире управления жизненным циклом,
но все равно крутятся вокруг компонентов.

Первая проблема, с которой я столкнулся, — это противопоставление компонентов и функций, их использующих.
У нас есть, в лучшем случае, десяток компонентов с внутренним состоянием,
таких как веб-сервер, соединения с базами данных, кэши,
и сотни функций, их использующих.

Самый простой способ использовать систему — это сначала передавать её через запрос в ring-обработчик,
а потом явно в каждую функцию первым аргументом.
И я даже слышал о больших и успешных проектах, использующих эту схему.
Могу отметить одно её преимущество: система явно передаётся по дереву вызовов функций,
и появляется возможность для веток указать другие компоненты, например, изменить уровень логирования.

Если использовать этот подход, то появляется один довольно странный компонент,
а именно ring-обработчик.
Веб-сервер, очевидно, зависит от обработчика.
Сам обработчик зависит от всех остальных компонентов и передаёт их в запрос.
Странный он потому, что, в этой схеме, это единственный компонент без состояния,
и который, по своей сути, является функцией.

Это натолкнуло меня на мысль, что кроме компонентов должны быть еще и сервисы -
функции-компоненты без состояния.
Сервисы могут зависеть или быть зависимостью других компонентов и сервисов.
Забегая вперед, отмечу, что сервис объявляется как обычная функция,
с первым дополнительным аргументом, описывающим зависимости через Clojure destrcuturing.

```clojure
(defn handler
  [{db      :db/datasource
    decoder `token/decoder}
   req]
  ;; some logic
  ,,,)
```

Обычно библиотеки управления жизненным циклом объявляют компоненты и зависимости между ними раздельно.
Компо

Однако, они не объясняют, как построить приложение вокруг этого подхода.
Приложение состоит не только из компонентов, таких как веб-сервер или подключение к базе данных,
но еще и из множества функций, реализующих бизнес-логику и использующих эти компоненты.


// объявление всех компонентов




С ростом проекта появляются новые требования.
Например, в нашем проекте, который распространяется по модели on-prem с множеством
независимых инсталляций, возникает необходимость отключения некоторых функций.
Если мы отключаем определённые функции, то их зависимости также не должны запускаться.
Например, если Redis используется только в отключаемой подсистеме,
то при её выключении Redis тоже не должен запускаться.

Так мы перешли ко второй проблеме. Это Push-модель.
Мы сначала запускаем систему, а потом проталкиваем её в приложение.
DI использует Pull-модель. На старте мы решаем, что нужно запустить,
и будет запущено только то, что необходимо.
















про 2 фазы





короче, тут нужно переход сделать

ввести сервисы

push vs pull
ленивая загрузка
к явной декларации зависимостей

2 стадии: сбор системы и использвание

перейти потом к фича-флагам


AOP






Но мне больше нравится подход, когда функции становятся на один уровень с компонентами.




Чтобы компоненты могли зависеть от таких функций
Я буду называть такие функции в дальнейшем Сервисами.




Но мне больше нравится подход, когда
...







Однако, они не объясняют, как построить приложение вокруг этого подхода.
Приложение состоит не только из компонентов, таких как веб-сервер или подключение к базе данных,
но еще и из множества функций, реализующих бизнес-логику и использующих эти компоненты.


Получается, что есть противопоставление между компонентами и функциями.

// развить



Самый очевидный способ использования системы - передать ее через Ring-запрос в обработчик.
и дальше явно прокидывается вглубь через аргументы функций.





Если использовать эти фреймворки еще и для внедрения зависимостей,
то приходится писать компоненты вместо обычных функций,
что усложняет код и затрудняет их переопределение в REPL.
А описание системы быстро растет, так как приходится повторно объявлять функции в компонентах.










# Компоненты и Сервисы

Компоненты в DI — это функции с дополнительными метаданными, которые определяют,
как управлять их жизненным циклом. Например:

```clojure
(defn jetty-server
  {::di/kind :component
   ::di/stop Server/.stop}
  [{handler :jetty/handler
    port    "PORT"}]
  (jetty/run-jetty handler ...))
```

В этом примере `jetty-server` — это компонент, который запускает Jetty-сервер с заданным обработчиком.
Метаданные `::di/kind :component` указывают, что эта функция является компонентом,
а `::di/stop определяет`, как компонент должен быть остановлен.


Чтобы упростить интеграцию компонентов в приложение и сделать их использование более гибким,
я добавил такую сущность, как сервисы.


Сервис в DI — это компонент, который также может быть вызван как обычная функция вне системы. Это позволяет использовать зависимости через Clojure destructuring, сохраняя гибкость при разработке.





В итоге я решил добавить к компонентам такую сущность, как сервисы.

Сервис - это компонент, и другие компоненты и сервисы могут зависеть от него.
Но при этом это обычная функция, которую можно вызвать вне системы.
Зависимости объявяются через clojure destructuring:


```clojure
(defn handler
  [{db      :db/datasource
    decoder `token/decoder}
   req]
  (decoder (::token/token req))
  ;; some logic
  :ok)

;; token ns
(defn decoder [{impl `impl} token]
  ,,,)
```

Каждый сервис при объявлении получает дополнительный первый аргумент,
в который передаются зависимости.
В примере выше сервис `decoder` примает 2 агрумента: зависимости и токен,
но `handler` вызывает его только с одним аргументом - токеном.


Компонент же это тоже функция но с дополнительными метаданными:

```clojure
(defn jetty-server
  {::di/kind :component
   ::di/stop Server/.stop}
  [{handler :jetty/handler
    port    "PORT"}]
  (jetty/run-jetty handler ...))
```




```clojure
(defmethod ig/init-key :web/root-handler [_ {:keys []}]
  (fn [req]
    :ok))


 (defmethod ig/init-key :web/a-handler [_ {:keys []}]
  (fn [req]
    :ok))

 ;; ...

 (defmethod ig/init-key :web/z-handler [_ {:keys []}]
  (fn [req]
    :ok))


(def ig-config
  {:jetty/server     {:port    8080
                      :handler (ig/ref :web/handler)}
   :web/route-data   {:root-handler (ig/ref :web/root-handler)
                      :a-handler (...)
                      :b-handler (...)
                      :c-handler (...)
                      :d-handler (...)
                      #_...
                      :z-handler (...)}
   :web/handler      {:route-data (ig/ref :web/route-data)}
   :web/root-handler {}
   :web/a-handler ...
   :web/b-handler ...
   :web/c-handler ...
   :web/d-handler ...
   #_...
   :web/z-handler ...})
```

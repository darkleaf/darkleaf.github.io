```haskell
(>>=)  :: m a -> (a -> m b) -> m b
```

```clojure
(mlet [x ::monad/list [1 2 3]
       y ::monad/list [4 5]]
  (+ x y))
```

Т.е. mlet это аналог do. И возращает как раз аргументы для >>=,
`m a` - это  `[1 2 3]`, а `(a -> m b)` это продолжение.

В этом то и отличие, я как бы немного вывернул или просмотрел с другой стороны.

И судя по всему тут можно мешать разные монады, как раз для этого и нужен 2ой параметр

По идее, получается, что мы рабоатем с одной супер монадой, что-то вроде IO.
В которой есть все, что дает язык.

Но тогда обработчик-интерпретатор должен быть очень странной формы.
Т.е. заранее поддерживать, напирмер completable future, передачу контекста и состояния.
Может быть получится сделать какой-то параметр-трансформер?

И зачем тогда все это? Может быть обычного DI хватит?

монадные законы посмотреть

Наверное, если где-то вылезет completable future, то интерпретатор ее и вернет.
Т.е. она всплывет, нужно проверить.

что делать с исключениями. наверное, интерпретатор может заставить скрипт кинуть исключение в точке останова?

диспетчерезация, через неймспейсы и resolve? нафига тут мультиметоды и реестры?

и что делать с applicative? не mlet, а alet?
см. мой пример с устранением n+1


добавлять туда `:let` и компанию? или сделать `<<-`. посмотреть promesa.

сравнение с yield, континуациями и core.async.
там в любой позиции можно вставить yield. И оно вроде как мощьнее do.
Но очень сложно преобразовывать. И дебажить.


# Монады и компания

Когда-то давно я прочитал несколько хороших объяснений, что такое монада и чем она полезна.
Тут я расскажу, что я думаю по этому поводу, на основе своего опыта.






```haskell
class Monad m where
  (>>=)  :: m a -> (  a -> m b) -> m b
  (>>)   :: m a ->  m b         -> m b
  return ::   a                 -> m a
```
